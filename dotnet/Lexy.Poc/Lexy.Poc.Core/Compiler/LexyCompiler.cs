using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Reflection;
using Lexy.Poc.Core.Language;
using Lexy.Poc.Core.RunTime;
using Lexy.Poc.Core.Transcribe;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Emit;
using Microsoft.Extensions.Logging;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Lexy.Poc.Core.Compiler
{
    //roslyn code is generated by https://roslynquoter.azurewebsites.net/

    public class LexyCompiler : ILexyCompiler
    {
        private readonly IExecutionEnvironment environment;
        private readonly ICompilerContext compilerContext;

        public LexyCompiler(ICompilerContext compilerContext, IExecutionEnvironment environment)
        {
            this.compilerContext = compilerContext ?? throw new ArgumentNullException(nameof(compilerContext));
            this.environment = environment ?? throw new ArgumentNullException(nameof(environment));
        }

        public CompilerResult Compile(Components components, Function function)
        {
            if (components == null) throw new ArgumentNullException(nameof(components));
            if (function == null) throw new ArgumentNullException(nameof(function));

            var generateNodes = FunctionComponentAndDependencies(components, function);

            var syntaxNode = GenerateSyntaxNode(components, generateNodes);
            var assembly = CreateAssembly(syntaxNode);

            environment.CreateExecutables(assembly);
            return environment.Result();
        }

        private List<IRootComponent> FunctionComponentAndDependencies(Components components, Function function)
        {
            var generateNodes = new List<IRootComponent> { function };
            generateNodes.AddRange(function.GetDependencies(components));
            return generateNodes;
        }

        private Assembly CreateAssembly(SyntaxNode syntax)
        {
            var compilation = CreateSyntaxTree(syntax);

            string fullString = null;
            if (compilerContext.Logger.IsEnabled(LogLevel.Debug))
            {
                fullString = syntax.ToFullString();
                compilerContext.Logger.LogDebug(fullString);
            }

            using var dllStream = new MemoryStream();
            using var pdbStream = new MemoryStream();

            var emitResult = compilation.Emit(dllStream, pdbStream);
            if (!emitResult.Success)
            {
                CompilationFailed(fullString ?? syntax.ToFullString(), emitResult);
            }

            return Assembly.Load(dllStream.ToArray());
        }

        private static CSharpCompilation CreateSyntaxTree(SyntaxNode root)
        {
            var syntaxTree = SyntaxTree(root);
            var references = GetDllReferences();

            return CSharpCompilation.Create(
                $"{WriterCode.Namespace}.{Guid.NewGuid():D}",
                new[] { syntaxTree },
                references,
                new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));
        }

        private void CompilationFailed(string code, EmitResult emitResult)
        {
            var compilationFailed = $"Compilation failed: {FormatCompilationErrors(emitResult.Diagnostics)}";

            compilerContext.Logger.LogError(compilationFailed);
            throw new InvalidOperationException($"{compilationFailed}{Environment.NewLine}code: {code}");
        }

        private static List<MetadataReference> GetDllReferences()
        {
            var references = new List<MetadataReference>
            {
                MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(FunctionResult).Assembly.Location)
            };

            Assembly.GetEntryAssembly().GetReferencedAssemblies()
                .ToList()
                .ForEach(reference =>
                    references.Add(MetadataReference.CreateFromFile(Assembly.Load(reference).Location)));


            /* var references = AppDomain.CurrentDomain.GetAssemblies()
                .Where(assembly => !assembly.IsDynamic && !string.IsNullOrEmpty(assembly.Location))
                .Select(assembly => (MetadataReference) MetadataReference.CreateFromFile(assembly.Location))
                .ToList();*/

            return references;
        }

        private SyntaxNode GenerateSyntaxNode(Components components, List<IRootComponent> generateComponents)
        {
            var members = generateComponents.Select(component =>
            {
                var writer = GetWriter(component);
                var generatedType = writer.CreateCode(component, components);

                environment.AddType(generatedType);

                return generatedType.Syntax;
            }).ToList();

            var namespaceDeclaration = NamespaceDeclaration(IdentifierName(WriterCode.Namespace))
                .WithMembers(List(members));

            var root = CompilationUnit()
                .WithUsings(List(
                    new[]{
                        Using("System.Collections.Generic"),
                        Using(typeof(IExecutionContext).Namespace)
                    }))
                .WithMembers(SingletonList<MemberDeclarationSyntax>(namespaceDeclaration));

            return root.NormalizeWhitespace();
        }

        private UsingDirectiveSyntax Using(string ns)
        {
            var usingDirective = UsingDirective(ParseName(ns));
            return usingDirective;
        }

        private static IRootTokenWriter GetWriter(IRootComponent rootComponent)
        {
            return rootComponent switch
            {
                Function _ => new FunctionWriter(),
                EnumDefinition _ => new EnumWriter(),
                Table _ => new TableWriter(),
                Scenario _ => null,
                _ => throw new InvalidOperationException("No writer defined: " + rootComponent.GetType())
            };
        }

        private static string FormatCompilationErrors(ImmutableArray<Diagnostic> emitResult)
        {
            var stringWriter = new StringWriter();
            foreach (var diagnostic in emitResult)
            {
                stringWriter.WriteLine($"  {diagnostic}");
            }

            return stringWriter.ToString();
        }
    }
}