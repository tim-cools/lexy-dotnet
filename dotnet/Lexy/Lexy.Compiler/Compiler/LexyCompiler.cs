using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Reflection;
using Lexy.Compiler.Compiler.CSharp;
using Lexy.Compiler.Language;
using Lexy.Compiler.Language.Functions;
using Lexy.RunTime;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Emit;
using Microsoft.Extensions.Logging;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Lexy.Compiler.Compiler
{
    //roslyn code is generated by https://roslynquoter.azurewebsites.net/

    public class LexyCompiler : ILexyCompiler
    {
        private readonly IExecutionEnvironment environment;
        private readonly ICompilerContext compilerContext;

        public LexyCompiler(ICompilerContext compilerContext, IExecutionEnvironment environment)
        {
            this.compilerContext = compilerContext ?? throw new ArgumentNullException(nameof(compilerContext));
            this.environment = environment ?? throw new ArgumentNullException(nameof(environment));
        }

        public CompilerResult Compile(RootNodeList rootNodeList, Function function)
        {
            if (rootNodeList == null) throw new ArgumentNullException(nameof(rootNodeList));
            if (function == null) throw new ArgumentNullException(nameof(function));

            var generateNodes = FunctionAndDependencies(rootNodeList, function);

            var syntaxNode = GenerateSyntaxNode(rootNodeList, generateNodes);
            var assembly = CreateAssembly(syntaxNode);

            environment.CreateExecutables(assembly);
            return environment.Result();
        }

        private List<IRootNode> FunctionAndDependencies(RootNodeList rootNodeList, Function function)
        {
            return function.GetFunctionAndDependencies(rootNodeList).ToList();
        }

        private Assembly CreateAssembly(SyntaxNode syntax)
        {
            var compilation = CreateSyntaxTree(syntax);

            string fullString = null;
            if (compilerContext.Logger.IsEnabled(LogLevel.Debug))
            {
                fullString = syntax.ToFullString();
                compilerContext.Logger.LogDebug(fullString);
            }

            using var dllStream = new MemoryStream();
            using var pdbStream = new MemoryStream();

            var emitResult = compilation.Emit(dllStream, pdbStream);
            if (!emitResult.Success)
            {
                CompilationFailed(fullString ?? syntax.ToFullString(), emitResult);
            }

            return Assembly.Load(dllStream.ToArray());
        }

        private static CSharpCompilation CreateSyntaxTree(SyntaxNode root)
        {
            var syntaxTree = SyntaxTree(root);
            var references = GetDllReferences();

            return CSharpCompilation.Create(
                $"{LexyCodeConstants.Namespace}.{Guid.NewGuid():D}",
                new[] { syntaxTree },
                references,
                new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));
        }

        private void CompilationFailed(string code, EmitResult emitResult)
        {
            var compilationFailed = $"Compilation failed: {FormatCompilationErrors(emitResult.Diagnostics)}";

            compilerContext.Logger.LogError(compilationFailed);
            throw new InvalidOperationException($"{compilationFailed}{Environment.NewLine}code: {code}");
        }

        private static List<MetadataReference> GetDllReferences()
        {
            var references = new List<MetadataReference>
            {
                MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(FunctionResult).Assembly.Location)
            };

            Assembly.GetEntryAssembly().GetReferencedAssemblies()
                .ToList()
                .ForEach(reference =>
                    references.Add(MetadataReference.CreateFromFile(Assembly.Load(reference).Location)));

            return references;
        }

        private SyntaxNode GenerateSyntaxNode(RootNodeList rootNodeList, List<IRootNode> generateNodes)
        {
            var root = GenerateCompilationUnitS(rootNodeList, generateNodes);

            return root.NormalizeWhitespace();
        }

        private CompilationUnitSyntax GenerateCompilationUnitS(RootNodeList rootNodeList, List<IRootNode> generateNodes)
        {
            var members = generateNodes
                .Select(node => GenerateMember(rootNodeList, node))
                .ToList();

            var namespaceDeclaration = NamespaceDeclaration(IdentifierName(LexyCodeConstants.Namespace))
                .WithMembers(List(members));

            var root = CompilationUnit()
                .WithUsings(List(
                    new[]
                    {
                        Using("System"),
                        Using("System.Collections.Generic"),
                        Using(typeof(IExecutionContext).Namespace)
                    }))
                .WithMembers(SingletonList<MemberDeclarationSyntax>(namespaceDeclaration));
            return root;
        }

        private MemberDeclarationSyntax GenerateMember(RootNodeList rootNodeList, IRootNode node)
        {
            var writer = CSharpCode.GetWriter(node);

            var generatedType = writer.CreateCode(node);

            environment.AddType(generatedType);

            return generatedType.Syntax;
        }

        private static UsingDirectiveSyntax Using(string ns) => UsingDirective(ParseName(ns));

        private static string FormatCompilationErrors(ImmutableArray<Diagnostic> emitResult)
        {
            var stringWriter = new StringWriter();
            foreach (var diagnostic in emitResult)
            {
                stringWriter.WriteLine($"  {diagnostic}");
            }

            return stringWriter.ToString();
        }
    }
}